# Bolg

ä¸ªäººçˆ±å¥½ï¼ŒçŸ¥è¯†ç§¯ç´¯ï¼Œç‚¹æ»´æˆçŸ³

## Web

webç«¯

[ç®€å•çš„Ajaxå°è£…](./web/Ajax/index.md)

[ç®€å•çš„Promiseå°è£…](web/Promise/PromiseClass.ts)

[ç®€å•çš„å¤§æ–‡ä»¶åˆ‡ç‰‡ä¸Šä¼ å°è£…](web/Upload/Upload.vue)

[vue3.0æ¨¡æ¿åˆæ¢](https://github.com/zys8119/vuit/tree/master/v3Template)

[å‰ç«¯å±å¹•å…±äº«](web/screenSharing/index.vue)

[windowè§†çª—](web/window/index.vue)

[webæ‰“å°ä»£ç ](web/print/index.md)

[vue3 åŠ¨æ•ˆ](web/3D/index.md)

[React Nativeç›¸å…³é—®é¢˜](web/ReactNative/index.md)

[Vue WebSocket ç®€å•å°è£…](web/WebSocket/index.md)

[Vue å‰ç«¯æ—¥å¿—ç›‘æ§æ’ä»¶ç®€å•å°è£…](web/Console/index.md)

[content-typeæ•´ç†](web/ContentType.md)

[vue å¯è§†åŒ–è¡¨å•é…ç½®](web/OneThingJointOffice/index.md)

[vue æ‚¬æµ®æ‹–æ‹½](web/suspension/suspension.js)

[vue van åˆ—è¡¨ä¸Šæ‹‰åˆ·æ–°](web/ListPage.vue)

[vue æ•°å­—æ»šåŠ¨æŒ‡ä»¤](web/VueNumber/README.md)

[vue é«˜å¾·åœ°å›¾çº¿è·¯è§„åˆ’](web/amap/README.md)

[vue TbaleH5 è¡¨æ ¼å°è£…](web/TbaleH5.md)

[vue Loading](web/Loading.md)

[vue åˆ†æ å¸ƒå±€](web/LayoutSplit.vue)

[vue3.0 å­—ä½“å“åº”å¼](web/FontResponse/index.md)

[svg paths è½¬ canvas è´å¡æ›²çº¿](web/svgToBezierCurve/index.md)

[canvas åŠ¨ç”»å‡½æ•°](web/canvas/animation.ts)

[canvas æ–‡å­—è‡ªåŠ¨æ¢è¡Œ](web/canvas/WrapText.ts)

[è·å–æ—¥å†æ•°æ®](web/CalendarDataJs.ts)

[javascript ç®—æ³•é¢˜åŠé¢˜è§£](web/JavascriptAlgorithm.md)

[vue3.0 åŸºç¡€è¡¨æ ¼ç®—æ³•](web/vue3table.md)

[å¤§æ•°æ®åœºæ™¯èƒŒæ™¯å›¾å¸ƒå±€å¿«é€Ÿå ä½](web/BigDataRapidPlaceholder.vue)

[Vite + Vue + monaco-editor](web/MonacoEnvironment.md)

[wisdom-plus + é«˜å¾·è‡ªå®šä¹‰åœ°å›¾ DemoMap.vue](web/DemoMap.vue)

[wisdom-plus + alert.tsx](web/alert.tsx)

[è¿›åº¦å›¾è¡¨ CommonProgressChart.vue](web/CommonProgressChart.vue)

[å ä½å›¾ä»£ç†](web/PlaceholderImage.md)

[vue3 è¡¨å•æäº¤é€šç”¨é€»è¾‘](web/vue3-form-submit.md)

[é¼ æ ‡æ‹–æ‹½åæ ‡æ•è· useMouseDownToMove.ts](web/useMouseDownToMove.ts)

[wp-alert åŠ¨æ€è¡¨å•å®ç°](web/DynamicFormImplementation.md)

[åŸºäºwujieçš„vue3å¾®å‰ç«¯ç»„ä»¶å°è£…](web/WujieVueRouterView.vue)

[è¡¨æƒ…è·å–](web/Emoji/index.md)

[vue3+vite åŠ¨æ€è·¯ç”±](web/vue/route.md)

[åˆ¤æ–­é¼ æ ‡è¿›å…¥æ–¹å‘](web/vue/determineDirectionMouseEntry.md)

[è·å–äº‹ä»¶å†’æ³¡è·¯å¾„ï¼Œå…¼å®¹ie11,edge,chrome,firefox,safari](web/eventPath.md)





## Serve

æœåŠ¡ç«¯

[nodeæ§åˆ¶å°è¾“å…¥äº¤äº’](serve/node/input.md)

[å‰ç«¯èµ„æºè‡ªåŠ¨åŒ–éƒ¨ç½²](serve/node/buildServe.js)

[å‰ç«¯èµ„æºjavascript-obfuscatorä»£ç æ··æ·†åŠ å¯†](serve/node/javascript-obfuscator-serve.ts)

[åˆ›å»ºFormDataæ•°æ®æ ¼å¼](serve/node/FormData.md)

[uf-node + vpn + giaoyun è®¢é˜…è·å–](serve/node/IndexController.ts)

[node-serve è®¢é˜…è·å–](serve/node/SubscriptionQcquisition.md)

[ä¾èµ–åŒ…æŸ¥æ‰¾](serve/DependentPackageLookup.ts)

[Chat Gpt AI](serve/ChatGpt.md)

[è·å–gitæŒ‡å®šHeadèŠ‚ç‚¹æ–‡ä»¶è¯¦æƒ…](serve/getHeadFileInfoList.md)

[nodejs 17 ä»¥ä¸‹fetchå…¼å®¹ï¼Œä»¥axiosæ–¹å¼-å¯è§£å†³llama-js åœ¨ä½ç‰ˆæœ¬çš„nodejsä¸­çš„æ­£å¸¸è¿è¡Œ](serve/fetch.ts)

[wisdom-node formData è§£æ](serve/formData.ts)

## å…¶ä»–

other

[å‘å¸ƒrelease.cmd](./other/å‘å¸ƒrelease.cmd)

[gitLab Release è‡ªåŠ¨åŒ–æ¨é€](./serve/push-release/README.md)

[git æäº¤è§„èŒƒæ ¡éªŒ](./other/HooksCommitMsg.js)

## å¤‡å¿˜

[åŒ—å¤–æµ‹è¯•é¢˜](./other/beiwaitest.md)


## UnoCsss è‡ªå®šä¹‰è§„åˆ™

```typescript
import { defineConfig } from 'unocss';

export default defineConfig({
    // ...UnoCSS options
    shortcuts: {
        'flex-center': 'flex justify-center items-center',
        'flex-center-start': 'flex justify-start items-center',
        'flex-center-end': 'flex justify-end items-center',
        'flex-center-between': 'flex justify-between items-center',
        'flex-center-around': 'flex justify-around items-center',
        'flex-v': 'flex flex-col',
        'abs-f': 'fixed',
        'abs-r': 'relative',
        abs: 'absolute',
        'size-content': 'left-0 top-0 w-100% h-100%',
        'abs-content': 'absolute left-0 top-0 w-100% h-100%',
        'abs-start': 'absolute left-0 top-0',
        'abs-end': 'absolute right-0 top-0',
        'abs-end-bottom': 'absolute right-0 bottom-0',
        'abs-start-bottom': 'absolute left-0 bottom-0',
        'abs-center': 'absolute left-50% top-50% translate--50%',
        'abs-x': 'absolute left-50% translate-x--50%',
        'abs-y': 'absolute top-50% translate-y--50%',
        bold: 'font-bold',
        'cur-p': 'cursor-pointer',
        'p-e-n': 'pointer-events-none',
    },
    rules: [
        [
            // åŒ…å«å°æ•°ç‚¹çš„ flex
            /^flex-?([0-9]+(?:\.[0-9]+)?)$/,
            (match) => {
                return {
                    flex: match[1],
                };
            },
        ],
        [
            /^tr-?([xy])(?:-?(-?.+))?$/,
            (match) => {
                return {
                    transform: `translate${match[1].toUpperCase() || 'Y'}(${match[2] || 0})`,
                };
            },
        ],
        [
            /^frame(?:-?(-?.+))?$/,
            (match) => {
                const [name, start, time, ...timing] = match[1].split('-');
                let timingFn = timing;
                let timeStr = time;
                if (time === 'cubic') {
                    timingFn = [time].concat(timing);
                    timeStr = '';
                }
                return {
                    animation: `${name} calc(1 - var(--sy) / ${start}) ${timeStr || ''} ${timingFn.join('-') || 'linear'} forwards reverse`,
                };
            },
        ],
        [
            // c-var--primary-color => color: var(--primary-color)
            /^c-var-([a-zA-Z0-9-]+)$/,
            (match) => {
                return {
                    color: `var(--${match[1]})`,
                };
            },
        ],
        [
            /^(s|size)-([a-zA-Z0-9-]+)$/,
            (match) => {
                return {
                    width: match[2],
                    height: match[2],
                };
            },
        ],
        [
            /^bg-(lg|rlg|rg|rrg|url)-(.{1,})$/,
            (match) => {
                return {
                    'background-image': `${
                        {
                            lg: 'linear-gradient',
                            rlg: 'radial-gradient',
                            rg: 'repeating-linear-gradient',
                            rrg: 'repeating-radial-gradient',
                            url: 'url',
                        }[match[1]]
                    }(${match[2].replace(/--/g, ' , ').replace(/-/g, ' ').replace(/\$([^\s]+)/g, 'var(--$1)')})`,
                };
            },
        ],
    ],
});


```
## uni-app å¾®ä¿¡å°ç¨‹åºä¹‹unocssè§„åˆ™
```typescript
import { defineConfig } from "unocss";
export default defineConfig({
  // ...UnoCSS optionstr
  configResolved(config) {
    config.preflights = [];
  },
  rules: [
    [
      /^u-?(text|bg|color|w)-?(.*)/,
      (m) => {
        return {
          text: `.${m[0]}{color:${m[2].replace("0x", "#")};}`,
          color: `.${m[0]}{color:${m[2].replace("0x", "#")};}`,
          bg: `.${m[0]}{background-color:${m[2].replace("0x", "#")};}`,
          w: `.${m[0]}{width:${m[2]}%;}`,
          h: `.${m[0]}{height:${m[2]}%;}`,
        }[m[1]];
      },
    ],
  ],
});

```
## js 16è¿›åˆ¶"fe7ae63d" å¦‚ä½•å¿«é€Ÿè½¬æˆæœ‰ç¬¦å·çš„10è¿›åˆ¶

```js
//10è¿›åˆ¶è½¬æˆæœ‰ç¬¦å·çš„10è¿›åˆ¶
function hexToSignedDecimal(hexStr) {
    // å°† 16 è¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ— ç¬¦å·çš„æ•´æ•°
    const unsignedInt = parseInt(hexStr, 16);

    // 32 ä½æœ‰ç¬¦å·æ•´æ•°çš„èŒƒå›´
    const INT32_MAX = 0x7FFFFFFF;
    const INT32_MIN = -0x80000000;

    // åˆ¤æ–­æ˜¯å¦ä¸ºè´Ÿæ•°
    if (unsignedInt > INT32_MAX) {
        // å¦‚æœæ— ç¬¦å·æ•´æ•°å¤§äº 0x7FFFFFFFï¼Œåˆ™å®ƒåœ¨æœ‰ç¬¦å·æ•´æ•°çš„è´Ÿæ•°èŒƒå›´å†…
        return unsignedInt - 0x100000000; // 0x100000000 æ˜¯ 2^32ï¼Œç”¨äºä»æ— ç¬¦å·è½¬æ¢ä¸ºæœ‰ç¬¦å·
    } else {
        // å¦‚æœä¸åœ¨è´Ÿæ•°èŒƒå›´å†…ï¼Œç›´æ¥è¿”å›å€¼
        return unsignedInt;
    }
}

const hexStr = "fe7ae63d";
const signedDecimal = hexToSignedDecimal(hexStr);

console.log(signedDecimal); // è¾“å‡º -126813651


// è½¬ç¬¦å·10è¿›åˆ¶ç¤ºä¾‹

function signedDecimalToHex(unsignedInt) {
    // åˆ¤æ–­æ˜¯å¦ä¸ºè´Ÿæ•°
    if (unsignedInt < 0) {
        // å¦‚æœæ— ç¬¦å·æ•´æ•°å¤§äº 0x7FFFFFFFï¼Œåˆ™å®ƒåœ¨æœ‰ç¬¦å·æ•´æ•°çš„è´Ÿæ•°èŒƒå›´å†…
        return (unsignedInt + 0x100000000).toString(16); // 0x100000000 æ˜¯ 2^32ï¼Œç”¨äºä»æ— ç¬¦å·è½¬æ¢ä¸ºæœ‰ç¬¦å·
    } else {
        // å¦‚æœä¸åœ¨è´Ÿæ•°èŒƒå›´å†…ï¼Œç›´æ¥è¿”å›å€¼
        return unsignedInt.toString(16);
    }
}
```

## sqlæ–‡ä»¶æ³¨é‡Šè§£æ

```typescript
import { readFileSync } from "fs"
/**
 * @name sqlCommitFunction sqlæ–‡ä»¶æ³¨é‡Šè§£æ
 * @param sqlFilePath sqlæ–‡ä»¶è·¯å¾„
 * @returns 
 */
export default function <T = Record<string, any>>(sqlFilePath: string): T{
    const sql = readFileSync(sqlFilePath, 'utf8')
    const sqlNames = []
    sql.replace(/\/\*(.|\n)*?\*\//g, function(m){
        const name = m.match(/@[^*\/]*/)?.[0].replace(/@|\n|\s/g,'') || ''
        sqlNames.push([name, m])
        return ``
    })
    let sqlCopy = sql
    return sqlNames.reverse().reduce((a,b)=>{
        const value = sqlCopy.slice(sql.lastIndexOf(b[1]))
        a[b[0]] = value.replace(b[1],'')
        sqlCopy = sqlCopy.replace(value, '')
        return a
    },{})
}
```

## puppeteer ç­‰å¾…é€‰æ‹©å™¨
```typescript
const waitForSelector = async (selector: string) => {
    return await page.evaluate(async function name(selector) {
        if (!document.querySelector(selector)) {
            return await new Promise(r => {
                requestAnimationFrame(async () => {
                    await name(selector)
                    r(true)
                })
            })
        }
    },selector)
}
```

## adbä¿æŒæ‰‹æœºå±å¹•ä¸å…³é—­ï¼Œè¯·ä½¿ç”¨tsnd è¿è¡Œ
```typescript
import { CronJob  } from 'cron';
import { execSync, execFileSync  } from 'child_process';
new CronJob('* * * * * *',()=>{
    try {
    execSync(`
screen_status=$(adb shell dumpsys power | grep "Display Power" | grep -o 'OFF')
if [ "$screen_status" = "OFF" ]; then
    echo "Screen is off";
    adb shell input keyevent 26;
fi;
adb shell dumpsys window | grep -i "current=[immersive]"
adb devices
        `,{
            stdio:'inherit',
        });
    }catch (error) {
        console.log(error)
    }
}).start();
```

## zsh å¸¸ç”¨æ’ä»¶
```
aliases            command-not-found  dirhistory         extract            git-prompt         macos              vscode             z                                                    
colored-man-pages  copyfile           docker             git                history            nmap               wd                                                                    
colorize           copypath           dotenv             git-commit         jsontools          sudo               web-search  
```

## rollup manualChunks for pnpm
```javascript
{
  manualChunks(id) {
      const deps = ['wp-request', 'lodash', 'vueuse/', 'vue/', 'lodash-es', 'vconsole-hide', 'gsap', 'qrcode', 'vant'];
      const dep = deps.find((dep) => new RegExp(`${__dirname}/node_modules.*${dep}`).test(id));
      if (dep) {
          return dep.replace(/\//g, '');
      }
      const depslocl = ['api', 'alert', 'datas', 'utils'];
      const dep2 = depslocl.find((dep) => id.includes(path.resolve(__dirname, 'src', dep)));
      if (dep2) {
          return dep2;
      }
  },
}
```

## CSS é‡ç½®

```css
/* 1. Use a more-intuitive box-sizing model */
*, *::before, *::after {
  box-sizing: border-box;
}

/* 2. Remove default margin */
* {
  margin: 0;
}

body {
  /* 3. Add accessible line-height */
  line-height: 1.5;
  /* 4. Improve text rendering */
  -webkit-font-smoothing: antialiased;
}

/* 5. Improve media defaults */
img, picture, video, canvas, svg {
  display: block;
  max-width: 100%;
}

/* 6. Inherit fonts for form controls */
input, button, textarea, select {
  font: inherit;
}

/* 7. Avoid text overflows */
p, h1, h2, h3, h4, h5, h6 {
  overflow-wrap: break-word;
}

/* 8. Improve line wrapping */
p {
  text-wrap: pretty;
}
h1, h2, h3, h4, h5, h6 {
  text-wrap: balance;
}

/*
  9. Create a root stacking context
*/
#root, #__next {
  isolation: isolate;
}
```
##  flutter sm4 åŠ è§£å¯†
```dart
import 'package:flutter/foundation.dart';
import 'package:dart_sm/dart_sm.dart';

class CryptoUtil {
  static String convertToHex(String input) {
    return input.runes.map((rune) {
      return rune.toRadixString(16);
    }).join();
  }

  static final String _SM4KEY = "";
  static final String iv = convertToHex(_SM4KEY);

  //SM4åŠ å¯†
  static String encryptedSM4(String content) {
    SM4.setKey(iv);
    String cipherText = SM4.encrypt(content, mode: SM4CryptoMode.CBC, iv: iv);
    return cipherText.toLowerCase();
  }

  //SM4è§£å¯†
  static String decryptSM4(String content) {
    SM4.setKey(iv);
    //Stopwatch stopwatch = Stopwatch()..start();
    String cbcDecryptData =
        SM4.decrypt(content, mode: SM4CryptoMode.CBC, iv: iv);
    //stopwatch.stop();
    // print('æ‰§è¡Œæ—¶é—´ï¼š${stopwatch.elapsedMilliseconds} æ¯«ç§’');
    return cbcDecryptData;
  }

  static Future<String> encryptedSM4ByAsync(String data) async {
    return await compute(encryptedSM4, data);
  }

  static Future<String> decryptSM4ByAsync(String data) async {
    return await compute(decryptSM4, data);
  }
}

```

## shell è„šæœ¬æå–ç§åŒ…

```shell
dir='packages'
node_modules_dir='node_modules'
package_json_dir='package.json'
packages=($(echo $(cat $package_json_dir | grep -e 'http' | awk '{print $1}' | sed 's/^"//g' | sed 's/":$//g')))
rm -rf $dir
for i in ${packages[@]};
do
    target=$dir/$i
    mkdir -p $target
    ls $node_modules_dir/$i | grep -E -v "node_modules" | xargs -I {} cp -r $node_modules_dir/$i/{} $target
done
```

## 242 æœåŠ¡viteä»£ç†é…ç½®

```
{
    '/242': {
        target: 'http://192.168.110.242/',
        rewrite: (path) => {
            console.log(path);
            return path.replace(/^\/242/, '');
        },
        headers: {
            Referrer: 'http://192.168.110.242'
        },
        autoRewrite: true,
        selfHandleResponse: true,
        // changeOrigin: true,
        ws: true,
        configure(proxy: HttpProxy.Server) {
            proxy.on('proxyRes', (proxyRes: IncomingMessage, req: IncomingMessage, res: ServerResponse) => {
                const chunks: any = [];
                proxyRes.on('data', (chunk) => {
                    chunks.push(chunk);
                });
                proxyRes.on('end', () => {
                    res.setHeader('access-control-allow-origin', '*');
                    res.end(Buffer.concat(chunks));
                });
            });
        }
    }
}
```

## flutter ä¾èµ–é‡å¯
```typescript
import { spawn } from "child_process";
import { watch } from "chokidar";
const run = () => {
  const child = spawn("flutter", ["run"], {
    stdio: "inherit",
    cwd: process.cwd(),
  });
  return child;
};
let child = run();
watch("./pdf_explorer", {
  cwd: process.cwd(),
  awaitWriteFinish: true,
}).on("change", (event, path) => {
  child.kill();
  child = run();
});


```
launch.json
```json
{
  // ä½¿ç”¨ IntelliSense äº†è§£ç›¸å…³å±æ€§ã€‚
  // æ‚¬åœä»¥æŸ¥çœ‹ç°æœ‰å±æ€§çš„æè¿°ã€‚
  // æ¬²äº†è§£æ›´å¤šä¿¡æ¯ï¼Œè¯·è®¿é—®: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "command": "tsnd  --respawn serve.ts  ",
      "name": "Run serve",
      "request": "launch",
      "type": "node-terminal"
    },
    {
      "name": "Flutter Attach",
      "request": "attach",
      "type": "dart",
      "flutterMode": "debug",
      "deviceId": "all"
    }
  ]
}

```

## è·å–pdfæ–‡ä»¶å­—ä½“

é…åˆæµè§ˆå™¨å­—ä½“apiå®Œæˆ,å¦‚ `document.fonts` `document.fonts.values()`

```
// æ£€æŸ¥ç‰¹å®šå­—ä½“æ˜¯å¦å·²åŠ è½½
function isFontAvailable(fontName) {
    return document.fonts.check(`16px "${fontName}"`);
}

// ä½¿ç”¨ç¤ºä¾‹
if (isFontAvailable('MySpecialFont')) {
    console.log('Font is available!');
} else {
    console.log('Font is not available.');
}

```

```
const pdfjsLib = require('pdfjs-dist/build/pdf');

async function checkMissingFonts(pdfUrl) {
    const loadingTask = pdfjsLib.getDocument(pdfUrl);
    const pdf = await loadingTask.promise;

    const missingFonts = new Set();

    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const operatorList = await page.getOperatorList();

        operatorList.argsArray.forEach((args, index) => {
            // æ£€æŸ¥æ“ä½œç¬¦æ˜¯å¦ä¸ºä½¿ç”¨å­—ä½“çš„æ“ä½œ
            if (operatorList.fnArray[index] === pdfjsLib.OPS.setFont) {
                const fontName = args[0];
                // è®°å½•å­—ä½“åç§°
                missingFonts.add(fontName);
            }
        });
    }

    console.log('Missing Fonts:', Array.from(missingFonts));
}

// ä½¿ç”¨ç¤ºä¾‹
checkMissingFonts('path/to/your.pdf');

```
æ›´æ”¹å­—ä½“,éœ€è¦å¯ç”¨pdfBugæ¨¡å¼
```
window.FontInspector = {
  enabled: true,
  fontAdded(font) {
    if (["g_d0_f1", "g_d0_f20", "g_d0_f3"].includes(font.loadedName)) {
      return;
    }
    font.loadedName = "Nabla";
  },
}
```

## javascript-obfuscator é…ç½®

```typescript
{
    controlFlowFlattening: true,
    stringArrayThreshold: 1,
    unicodeEscapeSequence: true,
    stringArrayEncoding: ['none', 'base64', 'rc4'],
    forceTransformStrings: ['.'],
    deadCodeInjection: true,
    deadCodeInjectionThreshold: 1,
    numbersToExpressions: true,
    renameGlobals: true,
    splitStrings: true,
    stringArray: true,
    disableConsoleOutput: true,
}
```
# é˜²æ­¢ debugger è°ƒè¯•
```typescript
(function _debuggerInit(){
  // Check if the DevTools are open by measuring the time taken to execute a function
  const start = Date.now();
  new Function(`debugger;`)()
  const end = Date.now()
  if(Date.now() - start > 100){
    location.replace('about:blank')
  }
  setTimeout(()=>{
    _debuggerInit()
  })
})()
```

# æ‹–æ‹½æ‚¬æµ®çƒ
```vue
<template>
    <div class="abs-f z-100000 right-0 bottom-$h5-bottom-nav-height tr-y--150px levitated-sphere" :style="style"
        ref="el">
        <Drager ref="drager" @drag-end="handleDragEnd" @drag-start="handleDragStart" v-bind="info2" v-if="show">
            <div class="op-$op levitated-sphere-content">
                <slot>
                    æ‚¬æµ®å†…å®¹
                </slot>
            </div>
        </Drager>
    </div>
</template>
<script setup lang="ts">
import Drager from 'es-drager'
import winframe from 'winframe'
const props = withDefaults(defineProps<{
    isOp?: boolean | number
}>(), {
    isOp: true
})
const el = ref()
const { top, height } = useElementBounding(el)
const info = ref({
    top: 0,
    left: 0,
})
const info2 = ref({
    top: 0,
    left: 0,
})
const style = computed(() => {
    return {
        right: info.value.left + 'px',
        bottom: info.value.top + 'px',
    }
})
const posY = computed(() => {
    return top.value + height.value
})
const drager = ref(null)
const show = ref(true)
const isOP = ref(true)
const handleDragStart = () => {
    isOP.value = false
}
useCssVars(() => ({
    op: props.isOp ? (isOP.value ? (typeof props.isOp === 'number' ? props.isOp : 0.5) : 1 as any) : 1
}))
const handleDragEnd = (e: any) => {
    isOP.value = true
    show.value = false
    info.value.left += -e.left
    info.value.top += -e.top
    const left = info.value.left
    nextTick(() => {
        show.value = true
        const copyPosY = posY.value
        const copyPosYOffset = copyPosY - height.value
        const top = info.value.top
        winframe((p) => {
            info.value.left = left * (1 - p)
            if (copyPosYOffset < 0) {
                info.value.top = top - height.value + copyPosYOffset * p
            }
            if (copyPosYOffset > innerHeight) {
                info.value.top = top + (copyPosYOffset - innerHeight) * p
            }
        }, 100)
    })
}
</script>
<style scoped lang="less">
.levitated-sphere {}
</style>
```
# å†å²é¢æ¿
```vue
<template>
    <div ref="history_el" class="abs-content hidden" :class="{
        'pointer-events-none': !isShowHistory
    }">
        <div ref="history_mask_el" class="abs left-0 top-0 h-100% w-100% bg-#000 bg-op-36 op-0"
            @click="handleShowHistory(false)"></div>
        <div ref="history_content_el" class="abs left-0 top-0 h-100% w-80% bg-#fff">
            <slot></slot>
        </div>
    </div>
</template>
<script setup lang="ts">
import winframe from 'winframe';
const history_el = ref() as unknown as Ref<HTMLDivElement>
const history_mask_el = ref() as unknown as Ref<HTMLDivElement>
const history_content_el = ref() as unknown as Ref<HTMLDivElement>
const isShowHistory = ref(false)
const debounceTime = ref(0)
const isDone = ref(true)
// timeout å•ä½msï¼Œå¼€å¯æˆ–å…³é—­çš„åŠ¨ç”»æ—¶é—´
const handleShowHistory = async (bool: boolean, timeout = 300, isMoveMode?: boolean) => {
    if (!isDone.value) return
    isDone.value = false
    debounceTime.value = performance.now()
    const opacity = Number(history_mask_el.value.style.opacity)
    if (bool) {
        history_el.value.style.display = 'block'
        history_mask_el.value.style.opacity = '0'
        await nextTick()
        const width = Math.abs(Number(history_content_el.value.style.transform.match(/translateX\((.*)px\)/)?.[1]) || history_content_el.value.offsetWidth)
        history_content_el.value.style.transform = `translateX(${-width}px)`
        await winframe(p => {
            history_mask_el.value.style.opacity = (isMoveMode ? opacity + (1 - opacity) * p : p) as unknown as string
            history_content_el.value.style.transform = `translateX(${-width * (1 - p)}px)`
        }, timeout)
        isShowHistory.value = true
    } else {
        history_el.value.style.display = 'block'
        await nextTick()
        const width = history_content_el.value.offsetWidth
        const width2 = Math.abs(Number(history_content_el.value.style.transform.match(/translateX\((.*)px\)/)?.[1]))
        history_mask_el.value.style.opacity = '1'
        history_content_el.value.style.transform = `translateX(${isMoveMode ? -width2 : 0}px)`
        await winframe(p => {
            history_mask_el.value.style.opacity = (isMoveMode ? opacity * (1 - p) : (1 - p)) as unknown as string
            const translateX = isMoveMode ? -width2 - (width - width2) * p : -width * p
            history_content_el.value.style.transform = `translateX(${translateX}px)`
        }, timeout)
        history_content_el.value.style.transform = `translateX(${-width}px)`
        history_mask_el.value.style.opacity = '0'
        history_el.value.style.display = 'none'
        isShowHistory.value = false
    }
    if (performance.now() - debounceTime.value > timeout) {
        isDone.value = true
    }
}
defineExpose({
    handleShowHistory
})
const useTouchmove = (cb: (data: {
    x: number,
    y: number,
    event: TouchEvent,
    type: 'touchstart' | 'touchmove' | 'touchend',
    isTouchstart: boolean,
}) => void) => {
    let clientX = 0
    let clientY = 0
    let offsetX = 0
    let offsetY = 0
    let isTouchstart = false
    const touchstart = (e: TouchEvent) => {
        clientX = e.touches[0].clientX
        clientY = e.touches[0].clientY
        isTouchstart = true
        cb({
            x: offsetX,
            y: offsetY,
            event: e,
            type: 'touchstart',
            isTouchstart,
        })
    }
    const touchmove = (e: TouchEvent) => {
        if (!isTouchstart) return
        offsetX = e.touches[0].clientX - clientX
        offsetY = e.touches[0].clientY - clientY
        cb({
            x: offsetX,
            y: offsetY,
            event: e,
            type: 'touchmove',
            isTouchstart,
        })
    }
    const touchend = (e: TouchEvent) => {
        cb({
            x: offsetX,
            y: offsetY,
            event: e,
            type: 'touchend',
            isTouchstart,
        })
        isTouchstart = false
        clientX = 0
        clientY = 0
        offsetX = 0
        offsetY = 0
    }
    return {
        start() {
            window.addEventListener('touchstart', touchstart)
            window.addEventListener('touchmove', touchmove)
            window.addEventListener('touchend', touchend)
        },
        stop() {
            window.removeEventListener('touchstart', touchstart)
            window.removeEventListener('touchmove', touchmove)
            window.removeEventListener('touchend', touchend)
        }
    }
}
const moveRectWidth = ref(0)
const hasScrollbar: any = (element: HTMLElement) => {
    if (!element || element.attributes.getNamedItem('history-max-box')) { return false }
    return element?.scrollHeight > element?.clientHeight || hasScrollbar(element?.parentElement as any) as unknown as any;
}
const {
    start,
    stop
} = useTouchmove(async ({ x, y, type, isTouchstart, event }) => {
    if (hasScrollbar(event.target as unknown as any)) {
        return
    }
    const mx = 50
    if (Math.abs(y) > mx) {
        handleShowHistory(false, undefined, true)
        return
    }
    if (isShowHistory.value || !history_el.value) { return }
    const offsetMvX = x - mx
    const offset = -moveRectWidth.value + offsetMvX
    setTimeout(async () => {
        if (type === 'touchstart') {
            history_el.value.style.display = 'block'
            history_mask_el.value.style.opacity = '0'
            history_content_el.value.style.transform = `translateX(-100%)`
            await nextTick()
            moveRectWidth.value = history_content_el.value.offsetWidth
            return
        }
        if (type === 'touchend') {
            // Math.abs(offsetMvX) > window.innerWidth / 6 åˆ¤æ–­æ˜¯å¦æ˜¯ç°å®æ»‘åŠ¨çš„æœ€å¤§é˜€å€¼ï¼Œé»˜è®¤æ˜¯å±å¹•çš„1/6
            handleShowHistory(Math.abs(offsetMvX) > window.innerWidth / 6, undefined, true)
            return
        }
    }, 0)
    if (isTouchstart && type === 'touchmove') {
        if (offset > 0 && offset < moveRectWidth.value) { return }
        if (x > mx) {
            history_mask_el.value.style.opacity = (1 - Math.abs(offset / moveRectWidth.value) as unknown as string)
            history_content_el.value.style.transform = `translateX(${offset}px)`
        }
    }

})
onMounted(() => {
    start()
})
onBeforeUnmount(() => {
    stop()
})
</script>
<style scoped lang="less">
.history {}
</style>
```

# ç§»åŠ¨ç«¯è§¦æ‘¸ç§»åŠ¨äº‹ä»¶
```typescript
const useTouchmove = (cb: (data: {
    x: number,
    y: number,
    event: TouchEvent,
    type: 'touchstart' | 'touchmove' | 'touchend',
    isTouchstart: boolean,
}) => void) => {
    let clientX = 0
    let clientY = 0
    let offsetX = 0
    let offsetY = 0
    let isTouchstart = false
    const touchstart = (e: TouchEvent) => {
        clientX = e.touches[0].clientX
        clientY = e.touches[0].clientY
        isTouchstart = true
        cb({
            x: offsetX,
            y: offsetY,
            event: e,
            type: 'touchstart',
            isTouchstart,
        })
    }
    const touchmove = (e: TouchEvent) => {
        if (!isTouchstart) return
        offsetX = e.touches[0].clientX - clientX
        offsetY = e.touches[0].clientY - clientY
        cb({
            x: offsetX,
            y: offsetY,
            event: e,
            type: 'touchmove',
            isTouchstart,
        })
    }
    const touchend = (e: TouchEvent) => {
        cb({
            x: offsetX,
            y: offsetY,
            event: e,
            type: 'touchend',
            isTouchstart,
        })
        isTouchstart = false
        clientX = 0
        clientY = 0
        offsetX = 0
        offsetY = 0
    }
    return {
        start() {
            window.addEventListener('touchstart', touchstart)
            window.addEventListener('touchmove', touchmove)
            window.addEventListener('touchend', touchend)
        },
        stop() {
            window.removeEventListener('touchstart', touchstart)
            window.removeEventListener('touchmove', touchmove)
            window.removeEventListener('touchend', touchend)
        }
    }
}
```

# è¡¨å•å°è£…
```vue
<template>
    <n-form class="formValidate" ref="formRef" :rules="rules" :model="modelValue" v-bind="config">
        <n-grid v-bind="gridProps" :cols="cols">
            <template v-for="(item, index) in field" :key="index">
                <n-grid-item v-bind="item.gridItemProps" :span="get(item, 'gridItemProps.span', cols)">
                    <n-form-item :label="item.label" :path="item.field" v-bind="item.config">
                        <template v-if="item.slots && item.slots.gridBefore">
                            <component :is="item.slots.gridBefore" :field="item.field" :rules="item.rules"
                                :formConfig="config" :formData="modelValue" />
                        </template>
                        <template v-if="componentMapConfig[item.component]">
                            <component :is="componentMapConfig[item.component]" v-bind="{
                                ...item.props,
                                [item.fieldModel || `value`]: modelValue[item.field],
                                [`onUpdate:${item.fieldModel || 'value'}`]: (v: any) => {
                                    modelValue[item.field] = v
                                }
                            }">
                                <!-- åŠ¨æ€æ’æ§½ç»§æ‰¿ï¼Œåç»­å…¶ä»–ç»„ä»¶ä¹Ÿå¯ä»¥è¿™æ ·åš -->
                                <template v-for="(slotItem, key) in item?.slots" :key="key" #[key]="scope">
                                    <template v-if="!builtInSlot.includes(key)">
                                        <component :is="slotItem" :field="item.field" :rules="item.rules"
                                            :formConfig="config" :formData="modelValue" v-bind="scope" />
                                    </template>
                                </template>
                            </component>
                        </template>
                        <template v-else>
                            <component v-if="item.component" :is="item.component" :field="item.field"
                                :rules="item.rules" :formConfig="config" :formData="modelValue" v-bind="{
                                    ...item.props,
                                    [item.fieldModel || `modelValue`]: modelValue[item.field],
                                    [`onUpdate:${item.fieldModel || 'modelValue'}`]: (v: any) => {
                                        modelValue[item.field] = v
                                    }
                                }" />
                        </template>
                        <template v-if="item.slots && item.slots.gridAefter">
                            <component :is="item.slots.gridAefter" :field="item.field" :rules="item.rules"
                                :formConfig="config" :formData="modelValue" />
                        </template>
                        <!-- åŠ¨æ€æ’æ§½ç»§æ‰¿ï¼Œåç»­å…¶ä»–ç»„ä»¶ä¹Ÿå¯ä»¥è¿™æ ·åš -->
                        <template v-for="(slotItem, key) in item?.slots" :key="key" #[getKey(key)]="scope">
                            <template v-if="builtInFormSlot.includes(key)">
                                <component :is="slotItem" :field="item.field" :rules="item.rules" :formConfig="config"
                                    :formData="modelValue" v-bind="scope" />
                            </template>
                        </template>
                    </n-form-item>
                </n-grid-item>
            </template>
        </n-grid>
    </n-form>
</template>
<script setup lang="ts">
import { FormRules, FormProps, GridProps } from 'naive-ui';
import * as naiveUI from 'naive-ui';
import { get } from 'lodash';
const getKey = (key: any) => {
    const name = (key || '').replace(/form/, '').toLowerCase();
    return name === 'default' ? null : name;
};
const builtInFormSlot = ref<any>(['formFeedback', 'formLabel']);
const builtInSlot = computed<any>(() =>
    ['gridBefore', 'gridAefter'].concat(builtInFormSlot.value)
);
const componentMapConfig = shallowRef<any>({
    input: naiveUI.NInput,
    number: naiveUI.NInputNumber,
    select: naiveUI.NSelect,
    cascader: naiveUI.NCascader,
    datePicker: naiveUI.NDatePicker,
    switch: naiveUI.NSwitch,
    upload: naiveUI.NProUpload,
    transferTree: naiveUI.NTransferTree,
});
const formRef = ref();
const props = defineProps<{
    modelValue: Record<string, any>;
    field: FormValidateField;
    config?: FormProps;
    gridProps?: GridProps;
}>();
const cols = computed(() => {
    return get(props.gridProps, 'cols', 1);
});
const emit = defineEmits(['update:modelValue']);
const { modelValue, field, config } = useVModels(props, emit);
const rules = computed(() => {
    return (field.value || []).reduce<FormRules>((acc, item) => {
        acc[item.field] = item.rules as FormRules[string];
        return acc;
    }, {} as Record<string, FormRules[string]>);
});
defineExpose({
    form: formRef,
    validate: () => {
        return formRef.value?.validate();
    },
});
</script>
<style scoped lang="less">
.formValidate {}
</style>




```
```typescript
export {};
import {
    FormRules,
    FormItemProps,
    InputProps,
    CascaderProps,
    SelectProps,
    DatePickerProps,
    SwitchProps,
    UploadProps,
    InputNumberProps,
    GridItemProps,
    TransferTreeProps,
} from 'naive-ui';
type FormValidateFieldItemComponent = {
    input: InputProps;
    select: SelectProps;
    cascader: CascaderProps;
    datePicker: DatePickerProps;
    switch: SwitchProps;
    upload: UploadProps;
    number: InputNumberProps;
    transferTree: TransferTreeProps;
};
import { Component, VNode, ExtractPropTypes } from 'vue';
declare global {
    type FormValidateField = FormValidateFieldItem[];
    type FormValidateFieldItem<
        C = keyof FormValidateFieldItemComponent | Component | VNode
    > = {
        label?: string;
        component: C;
        field: string;
        rules?: FormRules[string];
        config?: FormItemProps;
        gridItemProps?: GridItemProps;
        props?: C extends keyof FormValidateFieldItemComponent
            ? FormValidateFieldItemComponent[C]
            : C extends VNode | Component
            ? ExtractPropTypes<C>
            : never;
        slots?: {
            formFeedback?: Component | VNode;
            formLabel?: Component | VNode;
            gridBefore?: Component | VNode;
            gridAefter?: Component | VNode;
            [key: string]: Component | VNode;
        };
        fieldModel?: string;
    };
}

```


# ncol ç±»å‹è¡¥å……
```typescript
declare module "ncol" {
  interface Ncol {
    log(...arg: any[]): Ncol;
    error(...arg: any[]): Ncol;
    errorBG(...arg: any[]): Ncol;
    black(...arg: any[]): Ncol;
    blue(...arg: any[]): Ncol;
    success(...arg: any[]): Ncol;
    successBG(...arg: any[]): Ncol;
    info(...arg: any[]): Ncol;
    infoBG(...arg: any[]): Ncol;
    color(callback: (this: Ncol) => void): Ncol;
  }
  const ncol: Ncol;
  export = ncol;
}

```

# nodejsè¯»å–execl æ–‡ä»¶å¹¶æå–æ‰€æœ‰å›¾ç‰‡ï¼ˆæ¨èxlsxï¼‰
```typescript
import fs from "fs";
import path from "path";
import ExcelJS from "exceljs";

// å®šä¹‰Excelæ–‡ä»¶è·¯å¾„å’Œä¿å­˜å›¾ç‰‡çš„ç›®å½•
const excelFilePath = "2.xlsx"; // æ›¿æ¢ä¸ºä½ çš„Excelæ–‡ä»¶è·¯å¾„
const outputDir = "./output_images"; // å›¾ç‰‡ä¿å­˜ç›®å½•

// ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

async function extractImagesFromExcel(filePath: any) {
  try {
    // åˆ›å»ºä¸€ä¸ªæ–°çš„å·¥ä½œç°¿å®ä¾‹
    const workbook = new ExcelJS.Workbook();

    // åŠ è½½Excelæ–‡ä»¶
    await workbook.xlsx.readFile(filePath);

    // éå†æ¯ä¸ªå·¥ä½œè¡¨
    for (const file of (workbook as any).model.media) {
      if (file.type === "image") {
        try {
          // å°†å›¾ç‰‡ä¿å­˜åˆ°æ–‡ä»¶
          const imagePath = `${outputDir}/${file.name}.png`;
          fs.writeFileSync(imagePath, file.buffer);
          console.log(`Saved image: ${imagePath}`);
        } catch (e) {}
      }
    }

    console.log("All images extracted successfully.");
  } catch (error) {
    console.error("Error extracting images:", error);
  }
}

// è°ƒç”¨å‡½æ•°
extractImagesFromExcel(excelFilePath);

```
# nodejs pdf æ‰¹æ³¨ç»˜åˆ¶ï¼ˆéæµè§ˆå™¨æ–¹å¼ç»˜åˆ¶ï¼‰
```typescript
import { createCanvas } from "canvas";
import { writeFileSync, readFileSync } from "fs";
import { PDFDocument, PDFPage } from "pdf-lib";
class pdfForCanvasDraw {
  constructor() {}
  async init() {
    try {
      const pdfFileBuff = readFileSync("test1.pdf");
      const pdfDoc = await PDFDocument.load(pdfFileBuff);
      const pages = pdfDoc.getPages();
      for (let i = 0; i < pages.length; i++) {
        const page = pages[i];
        const { width, height } = page.getSize();
        const canvas = createCanvas(width, height);
        const ctx = canvas.getContext(
          "2d"
        ) as unknown as CanvasRenderingContext2D;
        ctx.clearRect(0, 0, width, height);
        //å¼€å§‹ç»˜åˆ¶===========================
        await this.draw({
          ctx,
          width,
          height,
          page,
        });
        //ç»“æŸç»˜åˆ¶============================
        const buffer = canvas.toBuffer("image/png");
        const pngImage = await pdfDoc.embedPng(buffer);
        writeFileSync("output.png", buffer);
        page.drawImage(pngImage, {
          x: 0,
          y: 0,
          width,
          height,
        });
      }

      writeFileSync("output.pdf", Buffer.from(await pdfDoc.save()));
    } catch (error) {
      console.error("Error:", error);
    }
  }
  async draw({
    ctx,
    page,
  }: {
    ctx: CanvasRenderingContext2D;
    width: number;
    height: number;
    page: PDFPage;
  }) {}
}
new pdfForCanvasDraw().init();
```

# æ— çº¸åŒ–pdfæ‰¹æ³¨nodejsæ¸²æŸ“

[écanvas ç‰ˆæœ¬,canvasä¼šå¯¼è‡´cpuçˆ†æ»¡](./serve/pdf-annotation-synthesis.ts)

```typescript
import { createCanvas } from "canvas";
import { PDFDocument, PDFPage } from "pdf-lib";
import { chunk } from "lodash";
type PenTypeMapRect = {
  left: number;
  right: number;
  top: number;
  bottom: number;
};
type PenTypeMapBRUSHPEN = {
  x: number;
  y: number;
};
type PenTypeMapTEXTPEN = {
  data: any;
  height: any;
  key: any;
  leftTopPdfSize: {
    height: any;
    width: any;
  };
  page: any;
  rightBottomPdfSize: {
    height: any;
    width: any;
  };
  scale: any;
  width: any;
  x: any;
  y: any;
  zoom: any;
};
export class PdfForCanvasDraw {
  get annotations() {
    return JSON.parse(this.annotationsStr);
  }
  constructor(public annotationsStr, public data: Buffer) {}
  async init() {
    try {
      const pdfDoc = await PDFDocument.load(this.data as any);
      const pages = pdfDoc.getPages();
      await Promise.all(
        new Array(pages.length).fill(0).map(
          (_, i) =>
            new Promise((resolve) => {
              (async () => {
                const page = pages[i];
                const { width, height } = page.getSize();
                const canvas = createCanvas(width, height);
                const ctx = canvas.getContext(
                  "2d"
                ) as unknown as CanvasRenderingContext2D;
                ctx.clearRect(0, 0, width, height);
                //å¼€å§‹ç»˜åˆ¶===========================
                await this.draw({
                  ctx,
                  width,
                  height,
                  page,
                  index: i,
                });
                //ç»“æŸç»˜åˆ¶============================
                const buffer = canvas.toBuffer("image/png");
                const pngImage = await pdfDoc.embedPng(buffer as any);
                page.drawImage(pngImage, {
                  x: 0,
                  y: 0,
                  width,
                  height,
                });
                resolve(i);
              })();
            })
        )
      );

      return Buffer.from(await pdfDoc.save());
    } catch (error) {
      console.error("Error:", error);
    }
  }
  toHex8(value: number) {
    let color = null;
    if (value >= 0) {
      color = value.toString(16);
    } else {
      const hex = (value >>> 0).toString(16).toUpperCase();
      color = ("00000000" + hex).slice(-8);
    }
    return chunk(color.slice(2) + color.slice(0, 2), 2)
      .map((e) => parseInt(e.join(""), 16))
      .reduce((a, b, k) => ((a[["r", "g", "b", "a"][k]] = b), a), {} as any);
  }
  async draw({
    ctx,
    index,
    height,
  }: {
    ctx: CanvasRenderingContext2D;
    width: number;
    height: number;
    page: PDFPage;
    index: number;
  }) {
    const devicePixelRatio = 1;
    await Promise.all(
      this.annotations
        ?.filter((e: any) => e.page === index)
        .map(
          (e: any) =>
            new Promise((resolve) => {
              (async () => {
                if (typeof e.data === "string") {
                  e.data = JSON.parse(e.data as unknown as string);
                }

                const { color: penColor, penWidthScale: penWidth } = JSON.parse(
                  e.data.pen
                );
                const { r, g, b, a } = this.toHex8(penColor) as any;

                switch (e.penType) {
                  case "UNDERWAVELINE":
                    // æ³¢æµªçº¿
                    await Promise.all(
                      (
                        JSON.parse(
                          e.data.mergeData as string
                        ) as Array<PenTypeMapRect>
                      ).map(async (ee) => {
                        const startX = ee.left * devicePixelRatio;
                        const startY = height - ee.bottom * devicePixelRatio;
                        const lineWidth =
                          ee.right * devicePixelRatio -
                          ee.left * devicePixelRatio;
                        const amplitude = 2;
                        const frequency = 0.8;
                        const offsetX = 0;
                        const offsetY = startY;
                        ctx.beginPath();
                        ctx.strokeStyle = `rgba(${r || 0}, ${g || 0}, ${
                          b || 0
                        }, ${a || 1})`;
                        ctx.lineWidth = penWidth;
                        ctx.moveTo(startX, startY);
                        for (let x = 0; x < lineWidth; x++) {
                          const y =
                            offsetY +
                            amplitude * Math.sin((x + offsetX) * frequency);
                          ctx.lineTo(startX + x, y);
                        }
                        ctx.stroke();
                        ctx.closePath();
                      })
                    );
                    break;
                  case "UNDERLINE":
                    // ä¸‹åˆ’çº¿
                    (
                      JSON.parse(
                        e.data.mergeData as string
                      ) as Array<PenTypeMapRect>
                    ).forEach((ee) => {
                      // ctx ç»˜åˆ¶çº¿æ®µï¼Œå®šä¹‰é¢œè‰²å’Œç²—ç»†
                      ctx.beginPath();
                      ctx.lineWidth = penWidth;
                      ctx.strokeStyle = `rgba(${r || 0}, ${g || 0}, ${
                        b || 0
                      }, ${a || 1})`;
                      ctx.moveTo(
                        ee.left * devicePixelRatio,
                        height - ee.bottom * devicePixelRatio
                      );
                      ctx.lineTo(
                        ee.right * devicePixelRatio,
                        height - ee.bottom * devicePixelRatio
                      );
                      ctx.stroke();
                      ctx.closePath();
                    });
                    break;
                  case "HIGHLIGHTPEN":
                    // çŸ©å½¢
                    (
                      JSON.parse(
                        e.data.mergeData as string
                      ) as Array<PenTypeMapRect>
                    ).forEach((ee) => {
                      ctx.beginPath();
                      ctx.fillStyle = `rgba(${r || 0}, ${g || 0}, ${
                        b || 0
                      }, 0.2)`;
                      ctx.fillRect(
                        ee.left * devicePixelRatio,

                        height - ee.top * devicePixelRatio,
                        (ee.right - ee.left) * devicePixelRatio,

                        (ee.top - ee.bottom) * devicePixelRatio
                      );
                      ctx.stroke();
                      ctx.closePath();
                    });
                    break;
                  case "BRUSHPEN":
                    // çº¿
                    (e.data.data as Array<PenTypeMapBRUSHPEN>).forEach(
                      (ee, k: number, arr: any[]) => {
                        if (!arr[k + 1]) {
                          return;
                        }
                        // ctx ç»˜åˆ¶çº¿æ®µï¼Œå®šä¹‰é¢œè‰²å’Œç²—ç»†
                        ctx.beginPath();
                        ctx.lineWidth = penWidth;
                        ctx.strokeStyle = `rgba(${r || 0}, ${g || 0}, ${
                          b || 0
                        }, ${a || 1})`;
                        ctx.moveTo(
                          ee.x * devicePixelRatio,
                          height - ee.y * devicePixelRatio
                        );
                        ctx.lineTo(
                          arr[k + 1].x * devicePixelRatio,
                          height - arr[k + 1].y * devicePixelRatio
                        );
                        ctx.stroke();
                        ctx.closePath();
                      }
                    );
                    break;
                  case "TEXTPEN":
                    await (async (data: PenTypeMapTEXTPEN) => {
                      ctx.fillStyle = `rgba(${r || 0}, ${g || 0}, ${b || 0}, ${
                        a || 1
                      })`;
                      const textMap = data.data.split("\n");
                      ctx.font = `30px é»‘ä½“`;
                      ctx.textBaseline = "top";
                      textMap.forEach((text: string, index: number) => {
                        ctx.fillText(
                          text,
                          data.leftTopPdfSize.width * devicePixelRatio,
                          height -
                            data.leftTopPdfSize.height * devicePixelRatio +
                            index * 30,
                          data.width * devicePixelRatio
                        );
                      });
                    })(e.data.data as PenTypeMapTEXTPEN);
                    break;
                }
                resolve(1);
              })();
            })
        )
    );
  }
}
export default PdfForCanvasDraw;
```

# excelè¡¨æ ¼å…¬å¼ä½¿ç”¨

ç›¸å…³ä¾èµ–

```json
{
  "@handsontable/vue3": "^15.2.0",
  "handsontable": "^15.2.0",
  "hyperformula": "^3.0.0",
}
```

å…·ä½“ä»£ç  

```vue
<template>
    <div class="aaaa abs-center w-80% h-80% of-auto">
        <hot-table v-bind="config"></hot-table>
    </div>
</template>
<script setup lang="ts">
import { HotTable } from '@handsontable/vue3';
import { registerAllModules } from 'handsontable/registry';
import 'handsontable/styles/handsontable.min.css';
import 'handsontable/styles/ht-theme-main.min.css';
import { HyperFormula, FunctionPlugin, FunctionArgumentType, ImplementedFunctions } from 'hyperformula';
registerAllModules();
const licenseKey = 'gpl-v3'
class MyCustomPlugin extends FunctionPlugin {
    static implementedFunctions: ImplementedFunctions = {
        GREET: {
            method: 'GREET',
            parameters: [
                { argumentType: FunctionArgumentType.ANY, },
            ],
            // å¦‚æœéœ€è¦å¤šå‚æ•°ï¼Œä½¿ç”¨repeatLastArgs
            repeatLastArgs: 1
        },
    };
    constructor(instance) {
        super(instance);
    }
    GREET(ast, state) {
        console.log(11, ast, state)
        return this.runFunction(
            ast.args,
            state,
            this.metadata('GREET'),
            (...firstName) => {
                return `ğŸ‘‹ Hello, ${firstName}!`;
            }
        );
    }
}
HyperFormula.registerFunctionPlugin(MyCustomPlugin, {
    enGB: Object.fromEntries(Object.entries(MyCustomPlugin.implementedFunctions).map(([key]: any) => [key, key]))
});

const data = ref([
    new Array(50).fill(''),
    ['', 'Ford', 'Volvo', 'Toyota', 'Honda'],
    ['2016', 10, 11, 12, 13],
    ['2017', 20, 11, 14, 13],
    ['2018', 30, 15, 12, "=sum(B5:D5)"],
    ['2018', 30, 15, 12, "=GREET(E5,E3)"]
]);
const config = ref({
    mergeCells: {
        cells: [{ row: 1, col: 1, rowspan: 3, colspan: 2 }]
    },
    formulas: {
        licenseKey,
        engine: HyperFormula.buildEmpty({
            language: 'enGB',
            licenseKey
        }),
    },
    matchWholeCell: true,
    licenseKey,
    data,
    colHeaders: true,
    rowHeaders: true,
})
onMounted(() => {
})
</script>
<style scoped lang="less">
.xlsx {}
</style>
```
# Luckysheet å®ç°æ–œè§’çº¿
```js
DIAGONALLINE: function () {
    if (arguments.length < this.m[0] || arguments.length > this.m[1]) {
      return formula.error.na;
    }
    const a = [];
    a.push.apply(a, arguments);
    return a
      .map(e => {
        try {
          if (typeof e == "object") {
            return e.data.v;
          }
          return e;
        } catch (e) {
          return e;
        }
      })
      .join("__DIAGONALLINE__");
  },
```
```js
/**
 * @param {*} cell å•å…ƒæ ¼
 * @param {*} postion å•å…ƒæ ¼ä½ç½®
 * @param {*} sheetFile å·¥ä½œè¡¨
 * @param {CanvasRenderingContext2D} ctx ç”»å¸ƒ
 * */
cellRenderAfter: function (cell, postion, sheetFile, ctx) {
  // console.log(postion);
  if (/^=DIAGONALLINE/.test(cell?.f)) {
    const value = cell.v?.split?.("__DIAGONALLINE__") || [cell.v];
    const x = postion.start_c;
    const y = postion.start_r;
    const ex = postion.end_c;
    const ey = postion.end_r;
    const w = Math.abs(postion.end_c - postion.start_c);
    const h = Math.abs(postion.end_r - postion.start_r);
    ctx.clearRect(x, y, w, h);
    ctx.fillStyle = cell.bg || "#fff";
    ctx.fillRect(x, y, w, h);
    let length = value.length - 1
    ctx.strokeStyle = cell.fc;
    ctx.lineWidth = 1;
    if (length % 2 !== 0) {
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(ex, ey);
      ctx.stroke();
      length -= 1
    }
    const length2 = length / 2
    for (let i = 0; i < length2; i++) {
      ctx.beginPath();
      ctx.moveTo(x, y);
      const width = w / (length2 + 1) * (i + 1)
      ctx.lineTo(width + x, ey);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x, y);
      const height = h / (length2 + 1) * (i + 1)
      ctx.lineTo(ex, height + y);
      ctx.stroke();
    }
    // è®¡ç®—æ–‡å­—ä½ç½®
    const textPos = []
    const length3 = ((length2 + 1) * 2)
    const textFontSize = typeof Number(cell.fs) === 'number' ? Number(cell.fs) : 16
    function getAngleFromTwoPoints(x1, y1, x2, y2) {
      const dy = y2 - y1;
      const dx = x2 - x1;
      const radians = Math.atan2(dy, dx); // å¤„ç†æ‰€æœ‰è±¡é™æƒ…å†µ
      const degrees = radians * (180 / Math.PI);
      return degrees;
    }
    function getPointOnLineByTwoPoints(x1, y1, x2, y2, t) {
      // t âˆˆ [0,1] è¡¨ç¤ºä» A åˆ° B çš„çº¿æ®µä¸Šç‚¹
      // t âˆˆ R è¡¨ç¤ºæ•´æ¡ç›´çº¿ä¸Šçš„ç‚¹
      const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))
      t -= String(value[textPos.length]).length * textFontSize / length
      const x = x1 + t * (x2 - x1);
      const y = y1 + t * (y2 - y1);
      return {
        x,
        y,
        angle: getAngleFromTwoPoints(x1, y1, x2, y2),
      };
    }
    const wz = 0.9
    for (let i = 0; i < length3; i++) {
      if (i % 2 !== 0) {
        continue
      }
      textPos.push(getPointOnLineByTwoPoints(x, y, x + w / length3 * (i + 1), h + y, wz))
      textPos.push(getPointOnLineByTwoPoints(x, y, x + w, h / length3 * (i + 1) + y, wz))
    }
    // ç»˜åˆ¶å†…å®¹

    ctx.font = `${cell.bl === 1 ? 'bold' : ''} ${cell.it === 1 ? 'italic' : ''} ${textFontSize}px ${cell.ff || 'sans-serif'} `
    ctx.fillStyle = cell.fc
    if (value.length === 1) {
      ctx.save();
      ctx.fillText(value[0], x + (w - textFontSize * String(value[0]).length) / 2, y + (h - textFontSize) / 2);
      ctx.restore();
    } else {
      value.forEach((item, index) => {
        ctx.save();
        ctx.translate(textPos[index].x, textPos[index].y);
        ctx.rotate(Math.PI / 180 * textPos[index].angle);
        ctx.textBaseline = "middle";
        ctx.fillText(item, 0, 0);
        ctx.restore();
      })
    }
  }
},
```
# æ•°æ®åº“è¿æ¥æ± node-serve ç®€å•å°è£…
```
import { createPool, QueryOptions } from "mysql2";
import * as ncol from "ncol";
const pool = createPool({
  host: "",
  port: 3306,
  user: "root",
  password: "",
  database: "",
  connectionLimit: 10,
});
export default function (sql: string | QueryOptions, values?: any) {
  return new Promise((resolve, reject) => {
    try {
      const query = pool.query(sql as any, values, (err: any, results) => {
        if (err) {
          ncol.color(() => {
            ncol
              .error("ã€SQLã€‘")
              .info(
                query.sql.replace(/ {1,}/g, " ").replace(/(\n ){1,}/g, "\n ")
              )
              .error("\nã€SQL_VALUESã€‘")
              .info(JSON.stringify(values, null, 4))
              .error("\n[SQL_MESSAGEã€‘")
              .error(err.sqlMessage);
          });
          reject(err);
        } else {
          ncol.color(() => {
            ncol
              .success("ã€SQLã€‘")
              .info(
                query.sql.replace(/ {1,}/g, " ").replace(/(\n ){1,}/g, "\n ")
              )
              .success("\nã€SQL_VALUESã€‘")
              .info(JSON.stringify(values, null, 4));
          });
          resolve(results);
        }
      });
    } catch (err) {
      ncol.color(() => {
        ncol.success("ã€SQLã€‘").success("\nã€SQL_VALUESã€‘").info(values);
      });
      reject(err);
    }
  });
}


```

### è®¡ç®—ä¸€å¹´åº¦çš„å‘¨æ•°ï¼Œç¬¬ä¸€å‘¨å¿…é¡»åŒ…å«å‘¨å››

```typescript
/**
 * æ ¹æ®å¹´ä»½è·å–æŒ‡å®šå¹´ä»½çš„weekä¿¡æ¯
 * @param year å¹´ä»½
 * @param startFirstDayByWeek éå›½é™…ç®—æ³•ï¼ŒæŒ‡å®šæ¯å¹´ç¬¬ä¸€å‘¨é‡æŒ‡å®šæ˜ŸæœŸå¼€å§‹ï¼Œé»˜è®¤å‘¨ä¸€å¼€å§‹ï¼Œ å–å€¼èŒƒå›´0-6ï¼Œ0ä¸ºå‘¨æ—¥ï¼ŒåŒdayjsä¸€è‡´
 */
const getYearWeekOption = (year: number, startFirstDayByWeek = 1) => {
    const startFirstDay = dayjs().year(year).startOf('year');
    const weekA = dayjs(startFirstDay).day()
    let startDay = null
    if (startFirstDayByWeek > 0) {
        // éå›½é™…ç®—æ³•ï¼ŒæŒ‡å®šæ¯å¹´ç¬¬ä¸€å‘¨é‡æŒ‡å®šæ˜ŸæœŸå¼€å§‹ï¼Œé»˜è®¤å‘¨ä¸€å¼€å§‹
        startDay = startFirstDay.add(startFirstDayByWeek - weekA, 'day')
    } else {
        // å›½é™…ç®—æ³•ï¼Œæ¯å¹´çš„ç¬¬ä¸€å‘¨å¿…é¡»åŒ…å«å‘¨å››
        if (weekA > 4) {
            // ä»Šå¹´
            startDay = startFirstDay.add(7 - weekA, 'day')
        } else {
            // éä»Šå¹´
            startDay = startFirstDay.add(-weekA, 'day')
        }
    }
    return {
        label: year,
        value: year,
        children: new Array(53).fill(0).map((_, k) => {
            const startWeekFirstDay = startDay.add(k * 7, 'day').set('hour', 0).set('m', 0).set('s', 0)
            const startWeekLastDay = startDay.add(k * 7 + 6, 'day').set('hours', 23).set('m', 59).set('s', 59)
            return {
                label: `ç¬¬${k + 1}å‘¨(${startWeekFirstDay.format('MMæœˆDDæ—¥')}-${startWeekLastDay.format('MMæœˆDDæ—¥')})`,
                value: `${year}å¹´ç¬¬${k + 1}å‘¨`,
                startTime: startWeekFirstDay.toDate().getTime(),
                endTime: startWeekLastDay.toDate().getTime(),
                year,
                week: k + 1,
                isEffective: startWeekFirstDay.year() <= year
            }
        }).filter(e => e.isEffective)
    }
}
/**
 * è·å–æŒ‡å®šå¹´ä»½çš„æ‰€æœ‰weekä¿¡æ¯
 * @param time æŒ‡å®šå¹´ä»½
 * @param offsetYear æŒ‡å®šå¹´ä»½çš„ä¸Šä¸‹æµ®åŠ¨çš„å¹´ä»½ï¼Œé»˜è®¤ä¸ºå‰å5å¹´
 */
const getYearWeekOptions = (time: any = null, offsetYear = 5) => {
    return new Array(offsetYear * 2 + 1).fill(0).map((_, index) => {
        const year = dayjs(time || dayjs()).add(index - offsetYear, 'year').year()
        return getYearWeekOption(year)
    });
}
/**
 * æ ¹æ®æ—¶é—´æŸ¥è¯¢æ‰€å±å‘¨ä¿¡æ¯
 * @param time æ—¶é—´
 */
const getWeekByDay = (time: any) => {
    const day = dayjs(time || dayjs())
    const year = day.year()
    const weekData = getYearWeekOption(year)
    const weekList = weekData.children
    const timeNow = day.toDate().getTime()
    return weekList.find(e => e.startTime <= timeNow && e.endTime >= timeNow) as typeof weekList[0]
}
// è·å–å½“å‰å¹´å¾€åæ¨5å¹´çš„å¹´ä»½
const getYearRange = async () => {
    options.value = getYearWeekOptions()
    const week = getWeekByDay(dayjs())
    checkDate.value = {
        key: week.year + 'å¹´ç¬¬' + week.week + 'å‘¨',
        year: week.year,
        week: week.week,
        startTime: week.startTime,
        endTime: week.endTime,
    };
    await getScheduleData();
};
```

### vue ç®€å•çš„å“åº”å¼ä»£ç†

```
<template>
    <div class='ref'></div>
</template>
<script setup lang="ts">
class shallowRef {
    constructor(value) {
        this._value = value;
    }
    subs = new Set();
    isRef = true;
    get value() {
        if (activeSub) {
            this.subs.add(activeSub);
        }
        return this._value;
    }
    set value(newValue) {
        this._value = newValue;
        this.subs.forEach((sub) => {
            sub();
        });
    }
}
function ref(value) {
    return new shallowRef(value);
}
let activeSub = null;
function effect(fn) {
    activeSub = fn;
    fn();
    activeSub = null;
}
function h(type, props, children) {
    return {
        type,
        props,
        children: Array.isArray(children) ? children : [children],
        render: (element) => {
            if (children && children.isRef) {
                element.innerText = children.value;
            } else {
                element.innerText = typeof children === 'function' ? children() : children;
            }
        },
        isVNode: true,
    }
}
const aa = ref(1222)
setInterval(() => {
    aa.value = Math.random();
}, 1000);
const a = ref(h('div', {
    class: 'w-500px h-500px bg-red-500',
    onClick: () => {
        console.log('click');
    }
}, [
    h('div', {
        class: 'w-100px h-100px bg-blue-500',
        onClick: () => {
            console.log('click');
        }
    }, 'child1'),
    h('span', {
        class: 'w-100px h-100px bg-green-500',
        onClick: () => {
            console.log('click');
        }
    }, 'child2'),
    h('div', {
        class: 'w-100px h-100px bg-green-500',
        onClick: () => {
            console.log('click');
        }
    }, h('span', {
        class: 'w-100px h-100px bg-green-500',
        onClick: (e: MouseEvent) => {
            e.stopPropagation();
            console.log('click');
        }
    }, () => `aa.value:${aa.value}`)),
]));
const el = useCurrentElement<HTMLElement>();
function renderElement(el, VNode) {
    const { type, props, children } = VNode;
    const element = document.createElement(type);
    VNode.el = element;
    for (const key in props) {
        if (/^on[A-Z]+/.test(key)) {
            const eventName = key.slice(2).toLowerCase();
            element.addEventListener(eventName, props[key]);
            continue;
        }
        element.setAttribute(key, props[key]);
    }
    children.forEach((child) => {
        if (child.isVNode) {
            renderElement(element, child);
        } else {
            effect(VNode.render.bind(null, element));
        }
    });
    el.appendChild(element);
}
function render() {
    el.value.innerHTML = "";
    renderElement(el.value, a.value)
}
onMounted(() => {
    effect(render);
})
</script>
<style scoped lang="less">
.ref {}
</style>
```
